#!/usr/bin/python
#
# Test program to verify that NFS client and server function properly
#
# Copyright (C) 2015-16 Olaf Kirch <okir@suse.de>
#
import sys
import suselog
import twopence
import susetest
import time

journal = None
server = None
client1 = None
client2 = None

nfstool	= "/usr/bin/nfs"

# The default fstype we will test on.
# "Extra" types will be tested as well for basic functionality
fstype_default = "btrfs"
fstype_extra = ['ext3', 'ext4', 'xfs']

# This dict maps names 'dir1', 'dir2', etc to the type of the underlying
# file system
dir2fstype = dict()
fstype2dir = dict()

def setup():
	global client1, client2, server, journal

	config = susetest.Config("nfs")

	journal = config.journal
	journal.beginGroup("setup")

	server = config.target("server")
	client1 = config.target("client1")

	try:
		client2 = config.target("client2")
	except:
		journal.info("No second client defined, skipping all two-client test cases")

	if not client1.ipaddr:
		journal.fatal("No IP address set for client1");
	if client2 and not client2.ipaddr:
		journal.fatal("No IP address set for client2");
	if not server.ipaddr:
		journal.fatal("No IP address set for server");

	# FIXME: we should also verify the host names of these nodes

def has_systemd(node):
	if not hasattr(node, "__has_systemd"):
		node.__has_systemd = False
		if node.run("test -x /usr/bin/systemctl"):
			node.__has_systemd = True
	return node.__has_systemd

##################################################################
# Initialize RPC tests and run some initial sanity checks
##################################################################
def init_server(node):
	global client1, client2;

	journal.beginGroup("server-init", "enable NFS server")

	nfs_init_common(node)

	for index in [1, 2, 3, 4]:
		create_filesystem(node, index)
	index = 5
	for fstype in fstype_extra:
		create_filesystem(node, index, fstype)
		index += 1

	journal.beginTest("enable nfsd and rpcbind on server")

	node.lastNFSRestart = 0

	if has_systemd(node):
		node.runOrFail("/usr/bin/systemctl enable nfsserver");
	else:
		node.runOrFail("insserv -d nfsserver");
	nfs_server_control(node, "start")

	# Help: add the two clients to the server's hosts file
	node.addHostEntry(client1.ipaddr, "client1.testing.opensuse.org")

	if client2:
		node.addHostEntry(client2.ipaddr, "client2.testing.opensuse.org")

	journal.beginTest("Check whether NFSv2 is enabled by default")
	status = node.runOrFail("cat /proc/fs/nfsd/versions")
	if status and status.stdout.find("-2") >= 0:
		journal.info("NFSv2 disabled on server by default");

		journal.beginTest("Enabling NFSv2 on server")
		node.changeSysconfigVar("nfs", "MOUNTD_OPTIONS", "-V2")
		node.changeSysconfigVar("nfs", "NFSD_OPTIONS", "-V2")
		node.runOrFail("rcnfsserver restart")

		journal.beginTest("Ensure that NFSv2 is enabled now")
		status = node.runOrFail("cat /proc/fs/nfsd/versions")
		if status and status.stdout.find("-2") >= 0:
			journal.failure("Oops, NFSv2 still disabled - expect quite a few failures")

	journal.finishGroup()

def create_filesystem(node, index, fstype = None):

	global fstype_default

	image_name = "/var/tmp/disk%u" % index
	mount_point = "/srv/nfs/dir%u" % index

	if not fstype:
		fstype = fstype_default

	journal.beginTest("Setting up file system %s" % mount_point)

	# When we run this script locally, we may have to
	# clean up from an earlier run. In slenkins, where
	# we're running on a fresh image every time, this is a NOP
	if node.run("test -f " + image_name):
		journal.info("Image %s exist. Cleaning up from previous run" % image_name)
		loopdev = loopdev_for_image(node, image_name)
		if loopdev:
			journal.info("Try to unmount and detach %s" % loopdev)
			node.run("umount " + loopdev)
			node.run("losetup -d " + loopdev)

		loopdev = loopdev_for_image(node, image_name)
		if loopdev:
			journal.fatal("Unable to detach loop device for image " + image_name)

		node.run("rm -f " + image_name)
		journal.info("Image %s cleaned up." % image_name)

	if not node.run("dd if=/dev/zero bs=1k seek=1023k count=1k of=%s" % image_name):
		journal.fatal("Unable to create image %s" % image_name)
	
	loopdev = loopdev_attach(node, image_name)

	journal.info("Creating file system on image %s" % image_name)
	if not node.run("mkfs -t %s %s" % (fstype, loopdev)):
		journal.fatal("Unable to create file system");

	journal.info("Mounting image %s on %s" % (image_name, mount_point))
	if not node.run("mkdir -p %s" % mount_point):
		journal.fatal("Unable to create mount point %s" % mount_point)

	if not node.run("mount %s %s" % (loopdev, mount_point)):
		journal.fatal("Unable to mount %s" % image_name)

	if not node.run("chmod 777 %s" % mount_point):
		journal.notice("Error changing directory permissions")
		journal.notice("Assuming that file system type %s is supported read-only" % fstype)
		journal.notice("Skipping all tests on this file system")
		node.run("umount %s" % mount_point)
		return False

	short_mount_point = "dir%u" % index
	if not fstype2dir.has_key(fstype):
		fstype2dir[fstype] = short_mount_point
	dir2fstype[short_mount_point] = fstype

	journal.success("File system %s is ready for service" % mount_point)
	return True

def loopdev_for_image(node, image_name):

	dev = None

	journal.info("Check if image %s is attached to a loop device" % image_name)
	status = node.run("losetup -j " + image_name)
	if status and status.stdout:
		dev = str(status.stdout).split(':')[0]
	if dev:
		journal.info("Image %s is attached to %s" % (image_name, dev))
	
	return dev

def loopdev_attach(node, image_name):

	dev = None

	journal.info("Trying to get next free loop device");
	status = node.run("losetup -f")
	if status and status.stdout:
		dev = str(status.stdout).strip()
	
	if not dev:
		journal.fatal("Unable to get a free loop device")
	
	journal.info("Next free loop device is %s" % dev)

	journal.info("Attaching image %s to %s" % (image_name, dev))
	if not node.run("losetup %s %s" % (dev, image_name)):
		journal.fatal("Failed to set up loop device")
	
	return dev

##################################################################
# Restart the NFS server.
# This records the time of the restart, so that we know how
# long to wait until NFSv4 grace period expires
##################################################################
def nfs_server_control(node, action):
	import time

	if action == "start" or action == "restart":
		node.lastNFSRestart = time.time();

	if has_systemd(node):
		node.runOrFail("systemctl %s nfsserver.service" % action)
	else:
		node.runOrFail("rcnfsserver " + action)

def nfs_server_wait_grace(node, grace_period = 90):
	import time

	if not node.lastNFSRestart:
		return

	# Top up the grace period - there seems to be some jitter sometimes
	grace_period = grace_period + 10

	elapsed = time.time() - node.lastNFSRestart;
	if elapsed < grace_period:
		nsleep = grace_period - elapsed
		journal.info("Wait for NFSv4 grace period to elapse - sleeping for %u seconds" % nsleep)
		time.sleep(nsleep)
	else:
		journal.info("NFS server restarted %u seconds ago - NFSv4 grace period should be over" % elapsed)

##################################################################
# Initialize an NFS client node
##################################################################
def init_client(node):
	global server;

	journal.beginTest("initialize client %s" % node.name)

	nfs_init_common(node)

	node.addHostEntry(server.ipaddr, "nfs-server.testing.opensuse.org")
	if not node.run("/usr/sbin/showmount -e nfs-server.testing.opensuse.org"):
		journal.fatal("Unable to contact NFS server")
		return False

	mtab = __nfs_mtab_get(node)
	for dir in ["dir1", "dir2", "dir3", "dir4"] + dir2fstype.keys():
		clientdir = __nfs_client_file(dir);
		if __nfs_mtab_find_mountpoint(mtab, clientdir):
			journal.info("Unmounting dir left mounted from previous test run")
			nfs_do_umount(node, dir);

		if not node.run("test -d %s || mkdir -p %s" % (clientdir, clientdir)):
			journal.fatal( "Failed to set up NFS mount points")
			return False

	# nfs_write_idmap_conf(node)

	# A simple start is not enough to make it start all helper services
	if has_systemd(node):
		if not node.run("systemctl start nfs.service"):
			journal.fatal("Failed to start NFS client services")
			return False;
	else:
		# SLE11 needs a special force-start target, otherwise
		# it will not start the NFS client services unless there's
		# an nfs mount point in /etc/fstab
		if not node.run("/etc/init.d/nfs force-start"):
			journal.fatal("Failed to start NFS client services")
			return False;

	# In current kernels, the default is to not perform ID mapping
	# in NFSv4 unless auth flavors other than AUTH_SYS are used.
	# Since we want to use it, enable it.
	# node.sendfile(remotefile = "/sys/module/nfs/parameters/nfs4_disable_idmapping", data = "N")

	return True

##################################################################
# Common initialization code for clients and server
##################################################################
def nfs_init_common(node):
	if node.run("test -x /usr/bin/systemctl"):
		node.runOrFail("/usr/bin/systemctl enable rpcbind.socket")
		node.runOrFail("/usr/bin/systemctl start rpcbind.socket")
	else:
		node.runOrFail("insserv -d rpcbind")
		node.runOrFail("/etc/init.d/rpcbind start")

	# exercise your shift key, stop the firewall
	node.runOrFail("rcSuSEfirewall2 stop")


##################################################################
# Update the idmapd.conf file on the given node
##################################################################
def nfs_write_idmap_conf(node):

	idmapd_conf = '''
[General]

Verbosity = 15
Pipefs-Directory = /var/lib/nfs/rpc_pipefs
Domain = testing.opensuse.org

[Mapping]

Nobody-User = nobody
Nobody-Group = nobody
'''

	node.sendfile(remotefile = "/etc/idmapd.conf", data = idmapd_conf)

##################################################################
# Two functions to display the server's idea of what is currently
# exported.
##################################################################
def nfs_show_userland_exports():
	global server

	journal.info("Trying to get list of exported file systems via exportfs")
	status = server.run("exportfs -v", quiet = True)
	if not status:
		journal.warning("unable to retrieve list of exported file systems");
	else:
		journal.info("Exported file systems (as seen by mountd):")
		for l in str(status.stdout).splitlines():
			journal.info(l)
		journal.info("---end of exportfs output---")

def nfs_show_kernel_exports():
	global server

	journal.info("Trying to retrieve kernel export table")
	st = server.run("cat /proc/fs/nfsd/exports", quiet = True)
	if not st:
		journal.warning("unable to retrieve list of exported file systems");
	else:
		journal.info("Content of kernel export table:")
		for l in str(st.stdout).splitlines():
			journal.info(l)
		journal.info("---end of kernel exports data---")

##################################################################
# Update the exports file on the given node, make nfsd reload
# the exports file, and use exportfs to provide the reader with
# hints of what acutally *did* get exported.
##################################################################
def nfs_write_exports(server, exports, reload_nfs = True):
	journal.info("%s: updating exports file:" % server.name)
	for l in exports.splitlines():
		if l:
			journal.info(l)
	journal.info("---end of exports file---")

	if not server.sendfile(remotefile = "/etc/exports", data = bytearray(exports)):
		journal.failure("unable to upload exports file")
		return False

	if (reload_nfs):
		if nfs_server_control(server, "reload"):
			return False
	else:
		journal.info("--- skipping reload of nfs configuration ---")
		journal.success("export file updated")
		return True
	# We need to flush the kernel's export cache explicitly.
	# The nfs init script will not do this for us automatically.
	journal.info("Flush kernel export cache")
	server.run("exportfs -f")

	# Busy-wait until the kernel exports cache has been flushed
	for repeat in range(0, 5):
		status = server.run("wc -l < /proc/fs/nfsd/exports")
		if not status:
			break
		if str(status.stdout).strip() == "2":
			break

		journal.warning("/proc/fs/nfsd/exports contains garbage after exportfs -f")

		import time
		time.sleep(1)

		if repeat > 2:
			journal.warning("Trying to flush cache once more")
			server.run("exportfs -f")

	nfs_show_userland_exports()
	nfs_show_kernel_exports()
	return True

def nfs_write_verify_exports(server, exports):
	global client1

	journal.beginTest("updating exports file on %s" % server.name)
	if nfs_write_exports(server, exports):
		journal.info("verifying visibility on the client side")
		client1.runOrFail("/usr/sbin/showmount -e %s" % server.ipaddr)

def nfs_check_exportfs(server, expected):
	import re

	journal.info("Retrieve list of exported file systems using exportfs")
	st = server.run("exportfs")
	if not st:
		journal.failure("unable to run exportfs")
		return False

	exp = expected.splitlines()
	want_dirs = []
	want_targets = []
	for l in exp:
		[dir, target] = l.split()

		# For now, we ignore all options present in the target part
		# i.e. "*(ro)" is translated to "*"
		target = re.sub("\([^)]*\)", "", target)

		want_dirs.append(dir)
		want_targets.append(target)

	got = str(st.stdout).splitlines()
	for l in got:
		[dir, target] = l.split()
		i = want_dirs.index(dir)
		if i < 0:
			journal.failure("Unexpected directory \"%s\" in exportfs output" % dir)
			return False

		if target == "<world>":
			target = "*";

		if want_targets[i] != target:
			journal.failure("Directory exported to \"%s\" but should be exported to \"%s\"" % (target, want_targets[i]))
			return False

		del want_dirs[i]
		del want_targets[i]

	if want_dirs:
		journal.failure("Directory \"%s\" not found in exportfs output" % want_dirs[0])
		if len(want_dirs) > 1:
			journal.info("%u directories missing in total" % len(want_dirs))
		return False

	journal.info("Good, server side exports match what we expect")
	return True


##################################################################
# Initialize server and clients
##################################################################
def nfs_init_all():
	global client1, client2, server

	if not server:
		setup()
		init_server(server);

		journal.beginGroup("client-init", "initialize clients")
		init_client(client1);
		if client2:
			init_client(client2);


##################################################################
# Mount and unmount a directory
##################################################################
def nfs_join_mount_options(left, right):
	if left and right:
		return left + "," + right
	if left:
		return left
	return right

def __nfs_do_mount(client, servername, clientdir, serverdir, options = None):
	journal.info("%s: mounting %s from %s (options %s)" % (client.name, serverdir, servername, options))
	if options:
		cmdline = "/bin/mount %s:%s %s -o %s" % (servername, serverdir, clientdir, options)
	else:
		cmdline = "/bin/mount %s:%s %s" % (servername, serverdir, clientdir)

	return client.run(cmdline)

def __nfs_do_umount(client, clientdir):
	rv = client.run("/bin/umount " + clientdir)
	if not rv and __nfs_is_mounted(client, clientdir):
		import time

		# Note, if the original umount call failed, we will always
		# return that failure status, even if we manage to unmount
		# the directory at a later point
		journal.warning("it seems we failed to unmount %s - maybe still busy" % clientdir)

		journal.info("Trying to kill off all processes accessing the directory")
		client.run("fuser -km " + clientdir)

		retry = 5
		while __nfs_is_mounted(client, clientdir) and retry > 0:
			journal.info("Sleeping for 10 seconds...")
			time.sleep(10)
			journal.info("Retrying unmount call")
			client.run("/bin/umount " + clientdir)
			retry -= 1

		if retry < 0:
			journal.info("Giving up")

def __nfs_is_mounted(node, dir):
	mtab = __nfs_mtab_get(node)
	if not mtab:
		return False

	return __nfs_mtab_find_mountpoint(mtab, dir)

def __nfs_mtab_get(node):
	# It would be nice to read the proc file directly, but unfortunately,
	# sshd doesn't handle /proc files correctly.
	journal.info("obtaining /proc/mounts from node " + node.name)
	st = node.run("cat /proc/mounts", suppressOutput = True)
	if not st:
		journal.failure("unable to extract /proc/mounts")
		return None
	
	return str(st.stdout)

def __nfs_mtab_find_mountpoint(mtab, dir):
	for l in mtab.split('\n'):
		l = l.split(' ')
		if len(l) > 1 and l[1] == dir:
			return True
	return False

##################################################################
# Mount and unmount a "standard" directory, ie mount
# /srv/nfs/dirX to /mnt/dirX on the client
##################################################################
def __nfs_server_file(dir, relativeName = None):
	path = "/srv/nfs/" + dir
	if relativeName:
		path += "/" + relativeName
	return path

def __nfs_client_file(dir, relativeName = None):
	path = "/mnt/" + dir
	if relativeName:
		path += "/" + relativeName
	return path

def nfs_do_mount(client, servername, dir, options = None):
	clientdir = __nfs_client_file(dir)
	serverdir = __nfs_server_file(dir)

	return __nfs_do_mount(client, servername, clientdir, serverdir, options)

def nfs_do_umount(client, dir):
	return __nfs_do_umount(client, __nfs_client_file(dir))

def __nfs_verify_mount(client, servername, dir):
	if not nfs_do_mount(client, servername, dir):
		return False
	return nfs_do_umount(client, dir);

def __nfs_mount_should_succeed(client, servername, dir, options = None):
	if options:
		journal.beginTest("mount with options %s" % options)
	else:
		journal.beginTest("mount without options")

	clientdir = __nfs_client_file(dir)
	serverdir = __nfs_server_file(dir)
	if __nfs_do_mount(client, servername, clientdir, serverdir, options):
		if __nfs_is_mounted(client, clientdir):
			journal.success()
			return True
		journal.failure("Directory was not mounted (which is bad), but mount(8) reported success (which is even worse)")
	elif __nfs_is_mounted(client, clientdir):
		journal.failure("Directory was mounted (which is good), but mount(8) reported an error")
	else:
		journal.failure("This mount attempt should have succeeded")
	return False

def nfs_mount_should_succeed(client, servername, dir, options = None):
	rv = __nfs_mount_should_succeed(client, servername, dir, options);
	nfs_do_umount(client, dir)
	return rv

def __nfs_mount_should_fail(client, servername, dir, options = None):
	if options:
		journal.beginTest("mount with options %s" % options)
	else:
		journal.beginTest("mount without options")

	clientdir = __nfs_client_file(dir)
	serverdir = __nfs_server_file(dir)
	if not __nfs_do_mount(client, servername, clientdir, serverdir, options):
		if not __nfs_is_mounted(client, clientdir):
			journal.success()
			return True
		journal.failure("Directory was mounted (which is good) even though mount(8) reported an error")
	elif not __nfs_is_mounted(client, clientdir):
		journal.failure("Directory was not mounted (which is good), but mount(8) reported success")
	else:
		journal.failure("This mount attempt should have failed")
	return False

def nfs_mount_should_fail(client, servername, dir, options = None):
	rv = __nfs_mount_should_fail(client, servername, dir, options);
	nfs_do_umount(client, dir)
	return rv

##################################################################
# Print an information message on how we're verifying readwrite/readonly
##################################################################
def nfs_verify_log_info(dirname, how, options, verifyUid = -1, verifyGid = -1):
	infomsg = "verify that %s is exported %s (" % (dirname, how)
	if options:
		infomsg += "mounted with options %s" % options
	else:
		infomsg += "mounted with default options"
	if verifyUid >= 0:
		infomsg += ", verify uid=%u" % verifyUid
	if verifyGid >= 0:
		infomsg += ", verify gid=%u" % verifyGid
	infomsg += ")"
	journal.info(infomsg)

##################################################################
# Create a file on a read-only volume
##################################################################
def __nfs_verify_readonly(client, filename, timeout = 0):

	import time

	t0 = time.time();

	if client.run("/bin/touch " + filename, timeout = timeout):
		journal.failure("file system should be read-only, but succeeded in creating file")
		nfs_show_kernel_exports()
		return False

	delay = time.time() - t0

	# We check how long this took, because a misconfigured/broken NFSv4 idmapping
	# may cause significant delays on the first access.
	if delay > 10:
		journal.failure("Creating the file took too long (%u seconds)" % delay)
		return False
	
	return True

def nfs_verify_readonly(dir, options):
	global client1, server

	# Log informational message
	nfs_verify_log_info(dir, "read-only", options)

	server.runOrFail("/bin/rm -f " + __nfs_server_file(dir, "readonly-test"))

	if not nfs_do_mount(client1, server.ipaddr, dir, options):
		journal.error("unable to mount file system")
		rv = False
	else:
		rv = __nfs_verify_readonly(client1, __nfs_client_file(dir, "readonly-test"))

	nfs_do_umount(client1, dir)
	return rv

##################################################################
# On the very first file operation after a reboot, the server
# make take very long to respond to the request.
# Try to deal with this gracefully, but still flag this as a
# problem.
##################################################################
def nfs_verify_readonly_slow(dir):
	global client1, server

	server.runOrFail("/bin/rm -f " + __nfs_server_file(dir, "readonly-test"))

	# TCP mount, retry operation after 20 seconds, retry twice.
	# This operation should time out after less than 60 seconds overall
	if not nfs_do_mount(client1, server.ipaddr, dir, "tcp,soft,intr,timeo=200,retrans=2"):
		rv = False
	else:
		rv = __nfs_verify_readonly(client1, __nfs_client_file(dir, "readonly-test"), 4 * 60)

	nfs_do_umount(client1, dir)
	return rv

##################################################################
# Create a file on a read-write volume
##################################################################
def __nfs_verify_readwrite(client, filename, verifyuid, verifygid):

	global server
	import time

	t0 = time.time();

	if not client.run("/bin/touch " + filename):
		journal.failure("file system should be read-write, but failed in creating file")
		nfs_show_kernel_exports()
		return False

	delay = time.time() - t0

	if verifyuid >= 0:
		st = client.run("/bin/stat -c %u " + filename, suppressOutput = True)
		if not st:
			journal.failure("Unable to stat created file")
			return False

		try:
			uid = int(st.stdout)
		except:
			uid = -1
		if uid != verifyuid:
			journal.failure("file should have been created with uid %u but has uid %u" % (verifyuid, uid))
			return False

	if verifygid >= 0:
		st = client.run("/bin/stat -c %g " + filename, suppressOutput = True)
		if not st:
			journal.failure("Unable to stat created file")
			return False

		try:
			gid = int(st.stdout)
		except:
			gid = -1
		if gid != verifygid:
			journal.failure("file should have been created with gid %u but has gid %u" % (verifygid, gid))
			return False

	# We check how long this took, because a misconfigured/broken NFSv4 idmapping
	# may cause significant delays on the first access.
	if delay > 10:
		journal.failure("Creating the file took too long (%u seconds)" % delay)
		return False


def nfs_verify_readwrite(dir, options, verifyuid = -1, verifygid = -1):
	global client1, server

	# Log informational message
	nfs_verify_log_info(dir, "read-write", options, verifyuid, verifygid)

	server.runOrFail("/bin/rm -f " + __nfs_server_file(dir, "readwrite-test"))

	server.syslogCapture()
	client1.syslogCapture()

	if not nfs_do_mount(client1, server.ipaddr, dir, options):
		journal.error("unable to mount file system")
		rv = False
	else:
		# For the time being, always display kernel exports table
		nfs_show_kernel_exports()

		rv = __nfs_verify_readwrite(client1, __nfs_client_file(dir, "readwrite-test"), verifyuid, verifygid)

	if not rv:
		server.syslogDisplay()
		client1.syslogDisplay()

	nfs_do_umount(client1, dir)
	return rv

##################################################################
# Verify that export matching works properly
##################################################################
def nfs_verify_exports_matching(testName, client, clientName, options = None):

	exports_data = '''
/srv/nfs/dir1   *(ro,no_subtree_check)
/srv/nfs/dir1   %s(rw,no_root_squash,no_subtree_check)
'''

	options = nfs_join_mount_options(options, "soft,intr");

	journal.beginTest(testName, "export read-write to " + clientName)
	nfs_write_exports(server, exports_data % clientName)
	nfs_verify_readwrite("dir1", options, 0, 0);

	# And now the other way around
	exports_data = '''
/srv/nfs/dir1   %s(ro,no_subtree_check) *(rw,no_root_squash,no_subtree_check)
'''

	journal.beginTest(testName + "-rev", "export read-only to " + clientName)
	nfs_write_exports(server, exports_data % clientName)
	nfs_verify_readonly("dir1", options)

def __nfs_ipv4_prefix(ipaddr, pfxlen):
	if pfxlen == 8:
		ipnetwork = ipaddr.rsplit('.', 3)[0]
		ipnetwork += ".0.0.0/8";
	elif pfxlen == 16:
		ipnetwork = ipaddr.rsplit('.', 2)[0]
		ipnetwork += ".0.0/16";
	elif pfxlen == 24:
		ipnetwork = ipaddr.rsplit('.', 1)[0]
		ipnetwork += ".0/24";
	elif pfxlen == 32:
		ipnetwork = ipaddr + "/32";
	
	return ipnetwork

def __nfs_ipv4_netmask(ipaddr, pfxlen):
	if pfxlen == 8:
		ipnetwork = ipaddr.rsplit('.', 3)[0]
		ipnetwork += ".0.0.0/255.0.0.0";
	elif pfxlen == 16:
		ipnetwork = ipaddr.rsplit('.', 2)[0]
		ipnetwork += ".0.0/255.255.0.0";
	elif pfxlen == 24:
		ipnetwork = ipaddr.rsplit('.', 1)[0]
		ipnetwork += ".0/255.255.255.0";
	elif pfxlen == 32:
		ipnetwork = ipaddr + "/255.255.255.255";
	
	return ipnetwork

##################################################################
# These functions test various peculiarities of the NFS
# file system
##################################################################
def nfstool_run(client, args):
	return client.runOrFail(nfstool + " " + args)

def __nfstool_run(client, args):
	return client.run(nfstool + " " + args)

def nfs_test_createfile(client, dir):

	tf = dir + "/testfile";

	# Open a file with O_CREAT.
	journal.beginTest("create file");
	if nfstool_run(client1, "create-file " + tf):
		journal.success()

	# Even if the above command returned error, the file may still
	# have been created.
	client1.run("/bin/rm -f " + tf)

	# Open a file with O_CREAT|O_EXCL, twice.
	journal.beginTest("Create file with O_EXCL, twice");
	journal.info("the first call should succeed, the second one should fail")
	if not __nfstool_run(client1, "create-file -x " + tf):
		journal.failure("First file open with O_EXCL failed (should have succeeded)")
	elif __nfstool_run(client1, "create-file -x " + tf):
		journal.failure("Second file open with O_EXCL succeeded (should have failed)")

	client1.runOrFail("/bin/rm -f " + tf)

def nfs_test_largefile(client, dir):

	tf = dir + "/testfile";

	# Open a file with O_CREAT.
	journal.beginTest("large file");
	journal.info("Create file and write 16K bytes at offset 4GB, then verify the data")
	if nfstool_run(client1, "create-file -c 16K -o 4G " + tf) and \
	   nfstool_run(client1, "verify-file -o 4G " + tf):
		journal.success()

	client1.runOrFail("/bin/rm -f " + tf)

def nfs_test_writefile(client, dir):

	tf = dir + "/testfile";

	journal.beginTest("write to file")
	if not client.run("/bin/dd if=/dev/zero of=%s bs=1k count=4k" % tf, timeout=120):
		journal.failure("Failed to write to file")

	client1.runOrFail("/bin/rm -f " + tf)

def nfs_test_chown(client, dir):

	tf = dir + "/testfile"

	journal.beginTest("change file's ownership")
	if client.runOrFail("touch " + tf):
		client.runOrFail("/bin/chown --changes nobody " + tf)

	client1.runOrFail("/bin/rm -f " + tf)

def nfs_test_chmod(client, dir):

	tf = dir + "/testfile"

	journal.beginTest("change file's permissions")
	if client.runOrFail("touch " + tf):
		client.runOrFail("/bin/chmod --changes 0600 " + tf)

	client1.runOrFail("/bin/rm -f " + tf)

def nfs_test_silly_rename(client, dir):

	src = dir + "/testfile1"
	dst = dir + "/testfile2"

	journal.beginTest("Verify silly-rename semantics")
	journal.info("Open dst, rename src to dst, verify both files")
	nfstool_run(client, "silly-rename %s %s" % (src, dst))
	client1.runOrFail("/bin/rm -f " + src)
	client1.runOrFail("/bin/rm -f " + dst)

	journal.beginTest("Verify silly-rename semantics #2")
	journal.info("Open dst, rename src to dst, verify both files. Leave src open the whole time")
	nfstool_run(client, "silly-rename -x %s %s" % (src, dst))
	client1.runOrFail("/bin/rm -f " + src)
	client1.runOrFail("/bin/rm -f " + dst)

def nfs_test_silly_unlink(client, dir):

	tf = dir + "/testfile"

	journal.beginTest("Verify silly-unlink semantics")
	journal.info("Open testfile, unlink it, verify content")
	nfstool_run(client, "silly-unlink " + tf)
	client1.runOrFail("/bin/rm -f " + tf)

def nfs_test_socket(client, dir):

	tf = dir + "/mysock"

	journal.beginTest("Verify socket creation")
	nfstool_run(client, "create-special -t socket -m 0644 " + tf)
	client1.runOrFail("/bin/rm -f " + tf)

def nfs_test_fifo(client, dir):

	tf = dir + "/myfifo"

	journal.beginTest("Verify FIFO creation")
	nfstool_run(client, "create-special -t fifo -m 0644 " + tf)
	client1.runOrFail("/bin/rm -f " + tf)

def nfs_test_chrdev(client, dir):

	tf = dir + "/devnull"

	journal.beginTest("Verify chardev creation")
	nfstool_run(client, "create-special -t chrdev -m 0644 -d 1:3 " + tf)
	client1.runOrFail("/bin/rm -f " + tf)

def nfs_test_blkdev(client, dir):

	tf = dir + "/devloop"

	journal.beginTest("Verify blockdev creation")
	nfstool_run(client, "create-special -t blkdev -m 0600 -d 7:0 " + tf)
	client1.runOrFail("/bin/rm -f " + tf)

def nfs_test_symlink(client, dir):

	link = dir + "/imasymlink"
	target = dir + "/testfile"
	basename = "testfile"

	journal.beginTest("Verify symlink operation")
	if not client.sendfile(target, data = bytearray("imadoofus")):
		journal.failure("unable to write target file")
		return False

	if client.runOrFail("/bin/ln -s %s %s" % (basename, link)):
		st = client.recvfile(link)
		if not st or str(st.buffer) != "imadoofus":
			journal.failure("problem verifying file content through symlink")

	journal.beginTest("Verify symlink operation #2")
	if client.run("/bin/ln -s randomlink %s" % link):
		journal.failure("/bin/ln -s on an existing symlink did not fail")

	client1.runOrFail("/bin/rm -f " + link)
	client1.runOrFail("/bin/rm -f " + target)

	# TBD: verify behavior of symlinks pointing outside the exported directory

def nfs_test_hardlink(client, dir):

	link = dir + "/imahardlink"
	target = dir + "/testfile"
	basename = "testfile"

	journal.beginTest("Verify hardlink operation")
	if not client.sendfile(target, data = bytearray("imadoofus")):
		journal.failure("unable to write target file")
		return False

	if client.runOrFail("/bin/ln %s %s" % (target, link)):
		st = client.recvfile(link)
		if not st or str(st.buffer) != "imadoofus":
			journal.failure("problem verifying file content through hardlink")

	journal.beginTest("Verify hardlink operation #2")
	if client.run("/bin/ln %s %s" % (target, link)):
		journal.failure("/bin/ln on an existing hardlink did not fail")

	client1.runOrFail("/bin/rm -f " + link)
	client1.runOrFail("/bin/rm -f " + target)


##################################################################
# General NFS mount testing
##################################################################
def nfs_test_mount():
	global client1, client2, server

	journal.beginGroup("mount")

	exports_data = '''
/srv/nfs/dir1   *(ro,no_subtree_check)
/srv/nfs/dir2   *(rw,no_root_squash,no_subtree_check)
/srv/nfs/dir3   *(rw,no_subtree_check)
'''

	nfs_write_verify_exports(server, exports_data)

	journal.beginTest("verify that we can mount from server by name")
	__nfs_verify_mount(client1, "nfs-server", "dir1");

	nfs_mount_should_succeed(client1, server.ipaddr, "dir1")
	nfs_mount_should_succeed(client1, server.ipaddr, "dir2")
	nfs_mount_should_succeed(client1, server.ipaddr, "dir3")
	nfs_mount_should_fail(client1,    server.ipaddr, "dir4")

	nfs_mount_should_succeed(client1, server.ipaddr, "dir1", "vers=2")
	nfs_mount_should_succeed(client1, server.ipaddr, "dir1", "vers=3")
	nfs_mount_should_succeed(client1, server.ipaddr, "dir1", "nfsvers=2")
	nfs_mount_should_succeed(client1, server.ipaddr, "dir1", "nfsvers=3")
	nfs_mount_should_succeed(client1, server.ipaddr, "dir1", "nfsvers=4")
	nfs_mount_should_succeed(client1, server.ipaddr, "dir1", "nfsvers=2,nolock")
	nfs_mount_should_succeed(client1, server.ipaddr, "dir1", "nfsvers=3,nolock")
	nfs_mount_should_succeed(client1, server.ipaddr, "dir1", "nfsvers=2,tcp")
	nfs_mount_should_succeed(client1, server.ipaddr, "dir1", "nfsvers=3,tcp")
	nfs_mount_should_succeed(client1, server.ipaddr, "dir1", "nfsvers=2,udp")
	nfs_mount_should_succeed(client1, server.ipaddr, "dir1", "nfsvers=3,udp")
	nfs_mount_should_succeed(client1, server.ipaddr, "dir1", "nfsvers=3,proto=tcp")
	nfs_mount_should_succeed(client1, server.ipaddr, "dir1", "nfsvers=3,proto=udp")

	# TBD: Mounting /srv/nfs/dir1/../../../etc should fail


def nfs_test_exports():

	global client1, client2, server

	exports_data = '''
/srv/nfs/dir1	*(ro,no_subtree_check)
/srv/nfs/dir2	*(rw,no_root_squash,no_subtree_check)
/srv/nfs/dir3	*(rw,no_subtree_check)
/srv/nfs/dir4	*(rw,root_squash,anonuid=60000,no_subtree_check)
'''

	# We run the NFSV4 tests last - hopefully we will be past the grace period then.
	# If not, we're prepared to wait for the remainder of the grace period to expire
	for version in [2, 3, 4]:
		journal.beginGroup("export-nfsv%d-basic" % version)

		nfs_write_verify_exports(server, exports_data)

		if version == 4:
			nfs_server_wait_grace(server)

		# Build the NFS mount options.
		# Always include intr so we're able to kill stuck processes
		options = "vers=%u" % version
		options = nfs_join_mount_options(options, "soft,intr");

		journal.beginTest("test read-only exports")
		nfs_verify_readonly("dir1", options);

		journal.beginTest("test read-write exports without root squashing")
		nfs_verify_readwrite("dir2", options, 0, 0);

		journal.beginTest("test read-write exports with root squashing")
		nfs_verify_readwrite("dir3", options, 65534, 65534);

		journal.beginTest("test read-write exports with root squashing and uid override")
		nfs_verify_readwrite("dir4", options, 60000, 65534);

		# We run export matching tests for both NFSv4 and NFSv3,
		# because they use two very different code paths (one going through
		# mountd, the other being authenticated by the kernel directly).

		journal.beginGroup("export-nfsv%d-matching" % version)

		##################################################################
		# Test IP prefix matching
		##################################################################
		nfs_verify_exports_matching("match-ipaddr", client1, client1.ipaddr, options)
		nfs_verify_exports_matching("match-ip-prefix8", client1, __nfs_ipv4_prefix(client1.ipaddr, 8), options)
		nfs_verify_exports_matching("match-ip-prefix16", client1, __nfs_ipv4_prefix(client1.ipaddr, 16), options)
		nfs_verify_exports_matching("match-ip-prefix24", client1, __nfs_ipv4_prefix(client1.ipaddr, 24), options)
		nfs_verify_exports_matching("match-ip-prefix32", client1, __nfs_ipv4_prefix(client1.ipaddr, 32), options)
		nfs_verify_exports_matching("match-ip-netmask8", client1, __nfs_ipv4_netmask(client1.ipaddr, 8), options)
		nfs_verify_exports_matching("match-ip-netmask16", client1, __nfs_ipv4_netmask(client1.ipaddr, 16), options)
		nfs_verify_exports_matching("match-ip-netmask24", client1, __nfs_ipv4_netmask(client1.ipaddr, 24), options)
		nfs_verify_exports_matching("match-ip-netmask32", client1, __nfs_ipv4_netmask(client1.ipaddr, 32), options)

		##################################################################
		# Test hostname matching
		##################################################################
		nfs_verify_exports_matching("match-fqdn", client1, "client1.testing.opensuse.org", options)
		nfs_verify_exports_matching("match-domain", client1, "*.testing.opensuse.org", options)


##################################################################
# If we're running in a systemd environment, ensure that
# the rcnfsserver init script continues to work as expected
##################################################################
def nfs_test_sysvinit():

	global client1, client2, server

	journal.beginGroup("sysvinit")

	my_exports = "/srv/nfs/dir1 *(rw)"
	running = True

	journal.beginTest("setup: stopping nfs server")
	nfs_server_control(server, "stop")
	running = False

	journal.beginTest("setup: write simple exports file to server")
	if not nfs_write_exports(server, my_exports, reload_nfs=False):
		journal.failure("Unable to initialize sysvinit tests")
		return False

	journal.beginTest("Check status of stopped NFS server")
	st = server.run("rcnfsserver status")
	if st.code != 3:
		journal.info("rcnfsserver status returned exit code %d" % st.code)
		journal.failure("rcnfsserver should have returned 3 [unused]")

	journal.beginTest("Try to start NFS server using rcnfsserver")
	if not server.run("rcnfsserver start"):
		journal.failure("that didn't work, it seems")
	else:
		running = True
	journal.beginTest("Check status of running NFS server")
	st = server.run("rcnfsserver status")
	if st.code != 0:
		journal.info("rcnfsserver status returned exit code %d" % st.code)
		journal.failure("rcnfsserver should have returned 0 [running]")

	if running:
		journal.beginTest("Verify list of exported file systems")
		nfs_check_exportfs(server, my_exports)

	journal.beginTest("Try to restart NFS server using rcnfsserver")
	if not server.run("rcnfsserver restart"):
		journal.failure("that didn't work, it seems")
	else:
		running = True

	if not running:
		# Try to recover enough so that we can run the subsequent test cases
		journal.beginTest("recovery: get nfs server back running")
		nfs_server_control(server, "stop")
		if not nfs_server_control(server, "start"):
			journal.fatal("unable to bring nfs server back to life")

	# change /etc/exports, run rcnfsservr reload and verify that
	# reload actually updated the list of exported file systems
	journal.beginTest("Try to reload exported file systems using rcnfsserver reload")
	my_exports = "/srv/nfs/dir2 *(ro)"

	journal.info("setup: write different exports file to server")
	if not nfs_write_exports(server, my_exports):
		journal.failure("Unable to update exports file")
	elif not server.run("rcnfsserver reload"):
		journal.failure("that didn't work, it seems")

	journal.beginTest("Verify list of exported file systems has been updated by reload")
	nfs_check_exportfs(server, my_exports)

def nfs_test_fileops():

	global client1, client2, server

	journal.beginGroup("fileops-init")

	# dir2fstype maps keys like "dir1" to the type of the
	# exported file system
	fstype_all = [fstype_default] + fstype_extra

	exports_data = ''
	for fstype in fstype_all:
		server_path = __nfs_server_file(fstype2dir[fstype])
		exports_data += "%s  *(rw,no_root_squash,no_subtree_check)\n" % server_path

	nfs_write_verify_exports(server, exports_data)

	for version in [2, 3, 4]:
		# Better safe than sorry
		options = nfs_join_mount_options("vers=%d" % version, "intr");

		for fstype in fstype_all:
			short_dirname = fstype2dir[fstype]

			journal.beginGroup("fileops-%s-nfs%d" % (fstype, version))

			journal.beginTest("Mounting %s file system via NFS with options %s" % (fstype, options))
			if not nfs_do_mount(client1, server.ipaddr, short_dirname, options):
				journal.info("Skipping fileops tests for these options - cannot mount directory");
				continue;

			clientdir = __nfs_client_file(short_dirname)
			nfs_test_createfile(client1, clientdir)
			nfs_test_writefile(client1, clientdir)
			nfs_test_chown(client1, clientdir)
			nfs_test_chmod(client1, clientdir)
			nfs_test_silly_rename(client1, clientdir)
			nfs_test_silly_unlink(client1, clientdir)
			nfs_test_socket(client1, clientdir)
			nfs_test_fifo(client1, clientdir)
			nfs_test_chrdev(client1, clientdir)
			nfs_test_blkdev(client1, clientdir)
			nfs_test_symlink(client1, clientdir)
			nfs_test_hardlink(client1, clientdir)

			if version >= 3:
				nfs_test_largefile(client1, clientdir)

			nfs_do_umount(client1, short_dirname)

##################################################################
# First things first - check that the NFSv4 grace period of
# 90 seconds is enforced
##################################################################
def nfs_test_nfsv4_grace(grace_period = 90):
	global client1, client2, server
	import time

	journal.beginGroup("nfsv4-grace")

	journal.beginTest("restarting NFS daemon")
	nfs_server_control(server, "restart")

	end_of_grace_period = server.lastNFSRestart + grace_period

	exports_data = '''
/srv/nfs/dir1   *(rw,no_root_squash,no_subtree_check)
'''

	nfs_write_verify_exports(server, exports_data)

	server_file = __nfs_server_file("dir1", "testfile")
	client_file = __nfs_client_file("dir1", "testfile")

	journal.beginTest("Checking for NFSv4 grace period")
	server.run("/bin/rm -f " + server_file)
	if not nfs_do_mount(client1, server.ipaddr, "dir1", "vers=4"):
		return False

	t0 = time.time();
	if not client1.run("/bin/touch " + client_file, timeout = 180):
		journal.failure("failed to create file")
		nfs_do_umount(client1, "dir1")
		return False
	t1 = time.time()

	nfs_do_umount(client1, "dir1")

	journal.info("Command took %u seconds to complete" % (t1 - t0))
	if t1 < end_of_grace_period - 1:
		journal.info("Command returned %u seconds too early" % (end_of_grace_period - t1))
		journal.failure("Server does not seem to enforce NFSv4 grace period")
	else:
		journal.success("Looks like the server enforces the grace period")
		

##################################################################
# File locking tests
##################################################################

def nfs_test_wait_grace(node, tf):

	# Before running all the locking tests, make sure that the grace period has
	# expired.
	journal.beginTest("grace-wait", "Make sure the locking grace period has expired")
	if node.run("/usr/bin/nfs lock -t 1 " + tf, timeout = 120):
		journal.success();
		ret = True
	else:
		journal.failure("Unable to obtain lock")
		node.run("/sbin/killproc -9 /usr/bin/nfs");
		ret = False

	return ret

def nfs_test_posix_lock1(tf):

	global client1

	journal.beginTest("Grab a shared POSIX lock")
	client1.runOrFail("/usr/bin/nfs lock -t 1 " + tf)

def nfs_test_posix_lock2(tf):

	global client1

	journal.beginTest("Grab an exclusive POSIX lock")
	client1.runOrFail("/usr/bin/nfs lock -t 1 -x " + tf)

def nfs_test_posix_lock3(tf):

	global client1

	journal.beginTest("Lock and unlock, then make sure GETLK reports no more locks")
	client1.runOrFail("/usr/bin/nfs lock -t 1 -u " + tf)

def nfs_test_posix_lock4(tf):

	global client1

	journal.beginTest("Grab a sequence of adjacent locks, unlock whole range, and make sure all locks are gone")
	client1.runOrFail("/usr/bin/nfs lock -t 1 -s -u " + tf)

def nfs_test_posix_lock5(tf):

	global client1, client2

	# Only run this test if we're using a twopence version that supports
	# backgrounded commands.
	try:
		client1.wait()
	except:
		return

	journal.beginTest("Grab shared POSIX locks on two clients")

	# Grab one lock on client1, holding that for 5 seconds
	if not client1.runBackground("/usr/bin/nfs lock -t 5 " + tf):
		journal.failure("Unable to run command in the background")

	# Wait for 1 second to make sure this guy has really had the time to grab the
	# lock
	time.sleep(1)

	# We grab a second shared lock on client2, and hold that for 1 second.
	# In case we block for some reason, we run the command with a 3 second
	if not client2.run("/usr/bin/nfs lock -t 1 " + tf, timeout = 3):
		journal.failure("Failed to grab shared lock on second client")
		client1.waitAll()
		return

	if not client1.wait():
		journal.failure("Failed to grab shared lock on first client")
		return

	journal.success()

def nfs_test_posix_lock6(tf):

	global client1, client2

	# Only run this test if we're using a twopence version that supports
	# backgrounded commands.
	try:
		client1.wait()
	except:
		return

	journal.beginTest("Grab exclusive POSIX locks on two clients")

	# Grab one lock on client1, holding that for 10 seconds
	if not client1.runBackground("/usr/bin/nfs lock -t 10 -x " + tf):
		journal.failure("Unable to run command in the background")
		return

	# Wait for 1 second to make sure this guy has really had the time to grab the
	# lock
	time.sleep(1)

	journal.info("Try to grab shared lock on second client, nonblocking - this should fail")
	if client2.run("/usr/bin/nfs lock -t 1 -n " + tf, timeout = 1):
		journal.failure("Grabbing the shared lock on second client succeeded!")
		client1.waitAll()
		return

	journal.info("Unable to grab lock on second client: good")

	journal.info("Try to grab shared lock on second client, blocking - this should block, then succeed")
	if not client2.run("/usr/bin/nfs lock -t 1 " + tf, timeout = 20):
		journal.failure("Blocking lock never acquired")
		client1.waitAll()
		return

	if not client1.wait():
		journal.failure("Failed to grab exclusive lock on first client?!")
		return

	journal.success()

def nfs_test_flock1(tf):

	global client1

	journal.beginTest("Grab a shared FLOCK lock")
	client1.runOrFail("/usr/bin/nfs lock -t 1 -b " + tf)

def nfs_test_flock2(tf):

	global client1

	journal.beginTest("Grab a exclusive FLOCK lock")
	client1.runOrFail("/usr/bin/nfs lock -t 1 -x -b " + tf)

def nfs_test_flock3(tf):

	global client1, client2

	# Only run this test if we're using a twopence version that supports
	# backgrounded commands.
	try:
		client1.wait()
	except:
		return

	journal.beginTest("Grab shared FLOCK locks on two clients")

	# Grab one lock on client1, holding that for 5 seconds
	if not client1.runBackground("/usr/bin/nfs lock -t 5 -b " + tf):
		journal.failure("Unable to run command in the background")

	# Wait for 1 second to make sure this guy has really had the time to grab the
	# lock
	time.sleep(1)

	# We grab a second shared lock on client2, and hold that for 1 second.
	# In case we block for some reason, we run the command with a 3 second
	if not client2.run("/usr/bin/nfs lock -t 1 -b " + tf, timeout = 3):
		journal.failure("Failed to grab shared lock on second client")
		client1.waitAll()
		return

	if not client1.wait():
		journal.failure("Failed to grab shared lock on first client")
		return

	journal.success()

def nfs_test_locking():

	global journal, client1, client2, server

	journal.beginGroup("locking-init")

	if not client1.run("test -x /usr/bin/nfs"):
		journal.error("/usr/bin/nfs missing on client1")
		return False
	if not client2.run("test -x /usr/bin/nfs"):
		journal.error("/usr/bin/nfs missing on client2")
		return False

	exports_data = '''
/srv/nfs/dir1	*(rw,no_root_squash,no_subtree_check)
'''
	nfs_write_verify_exports(server, exports_data)

	for options in ["vers=2", "vers=3", "vers=4"]:
		# Better safe than sorry
		options = nfs_join_mount_options(options, "intr");

		journal.beginGroup("locking-%s" % options)

		journal.beginTest("Mounting dir with options " + options)
		if not nfs_do_mount(client1, server.ipaddr, "dir1", options):
			journal.info("Skipping locking tests for these options - cannot mount directory");
			continue;

		if not nfs_do_mount(client2, server.ipaddr, "dir1", options):
			journal.info("Skipping locking tests for these options - cannot mount directory");
			nfs_do_umount(client1, dir)
			continue;

		testfile = __nfs_client_file("dir1") + "/testfile"
		if nfs_test_wait_grace(client1, testfile):
			nfs_test_posix_lock1(testfile)
			nfs_test_posix_lock2(testfile)
			nfs_test_posix_lock3(testfile)
			nfs_test_posix_lock4(testfile)
			nfs_test_posix_lock5(testfile)
			nfs_test_posix_lock6(testfile)

			# FIXME: we may want to kill any leftover nfs processes on both clients at this point

			nfs_test_flock1(testfile)
			nfs_test_flock2(testfile)
			nfs_test_flock3(testfile)
		else:
			journal.warning("Skipping all locking tests")

		client1.runOrFail("rm -f " + testfile)

		nfs_do_umount(client1, "dir1")
		nfs_do_umount(client2, "dir1")

##################################################################
# Ensure that file attributes are validated when reopening a
# file (also called close-to-open (cto) consistency
##################################################################
def nfs_test_cto(tf):

	global client1, client2

	journal.beginTest("cto", "Test close-to-open consistency")

	journal.info("On client1, write 'frank' to the testfile");
	client1.run("echo -n frank >" + tf)

	journal.info("On client2, append 'zappa' to the testfile");
	client2.run("echo -n zappa >>" + tf)

	# Expect the *first* client to revalidate attrs when reopening
	# the file, and discard its cache. IOW the current file content, 
	# which is "frankzappa", should be visible on the first client,
	# too.
	journal.info("Read the test file on client1")
	status = client1.run("cat " + tf)
	if not(status):
		journal.failure("unable to read testfile on client1")
	else:
		after = str(status.stdout)
		if after == "frankzappa":
			journal.success("Great: file contains \"frankzappa\"")
		else:
			journal.failure("Too bad: file contains \"%s\" (expected \"frankzappa\")" % after)

##################################################################
# Test mmap/lock coherence behavior
##################################################################
def __nfs_test_lock_coherence(tf, mode):

	global client1, client2

	# Run "nfs coherence" with
	#   8 slots (one slot is page sized)
	#  32 iterations
	#  2min timeout
	# Mode is one of
	#  stdio:	use read/write and rely on implicit
	#		data synching by the unlock operation
	#  stdio-sync:	use read/write and explicitly call
	#		fdatasync prior to unlocking a record
	#  stdio-osync:like stdio, but open the file with O_SYNC
	#  stdio-odirect:
	#		like stdio, but open the file with O_DIRECT
	#  mmap:	use mmap to map the file into memory, then
	#		use regular memory access.
	#		Rely on implicit data synching by the unlock
	#		operation. (This doesn't seem to be supported
	#		by the Linux kernel at the moment)
	#  mmap-sync	use mmap, and explicitly call msync() prior
	#		to unlocking a record.
	command = "/usr/bin/nfs coherence -c 8 -i 32 -t 120 -M %s " % mode

	# Clean up from previous runs
	if not client1.runOrFail("rm -f " + tf):
		journal.info("This should not have failed; something's really wrong")
		return False

	# On client1, start the mmap challenger
	# The -w option instructs the challenger to sleep for 500ms
	# on average while holding the lock. Long intervals make this
	# test take forever, while shorter intervals decrease the
	# likelihood of lock requests actually blocking.
	journal.info("Starting the challenger on client1")
	if not client1.runBackground(command + "-w 500 " + tf):
		return False

	# The challenger creates the test file, then locks it
	# (it should really create a temp file, lock it, then move it to the
	# final path).
	journal.info("Waiting for challenger to start")
	ready = False
	for n in range(0, 10):
		if client1.run("test -f " + tf):
			journal.info("ready!")
			ready = True
			break
		journal.info("snore...")
		time.sleep(1)

	if not ready:
		journal.failure("challenger did not start")
		return False

	time.sleep(1)

	# On client2, start the responder.
	# The -r option puts the tool in responder mode
	journal.info("Starting the responder on client2")
	if not client2.run(command + "-r " + tf):
		journal.failure("responder returned error")
		return False

	status = client1.wait()
	if not status:
		journal.failure("challenger exited with error")
		return False

	return True

def nfs_locktest_cleanup(tf):
	# Something went wrong. Clean up
	client1.run("/sbin/killproc -9 /usr/bin/nfs")
	client1.waitAll()

	client2.run("/sbin/killproc -9 /usr/bin/nfs")
	client2.waitAll()

	client1.run("rm -f " + tf)

def nfs_test_lock_coherence(tf, options):

	# Only run these tests if we're using a twopence version that supports
	# backgrounded commands.
	try:
		client1.wait()
	except:
		return

	journal.info('''
This set of tests validates the data coherence of NFS.

A file of 8 page-sized slots is accessed simultaneously by a challenger 
and a responder process. The challenger process writes a "challenge" word
to each slot, and expects the responder to echo this back. Both processes
use POSIX locks to prevent concurrent access during the read/write operations.

The file will be accessed either using regular read/write system calls,
or by mapping it into memory using mmap. Additional synchronization can
be provided by using fsync/msync/directio.
''')

	# Turn on lockd debugging
	# client2.run("/usr/sbin/rpcdebug -m nlm all")

	if options:
		extramsg = " (with mount options %s)" % options
	else:
		extramsg = " (with default mount options)"

	journal.beginTest("locked read/write with implicit flush/revalidate" + extramsg)
	if not __nfs_test_lock_coherence(tf, "stdio"):
		nfs_locktest_cleanup(tf)

	journal.beginTest("locked read/write/fsync coherence" + extramsg)
	if not __nfs_test_lock_coherence(tf, "stdio-sync"):
		nfs_locktest_cleanup(tf)

	journal.beginTest("locked read/write/directio coherence" + extramsg)
	if not __nfs_test_lock_coherence(tf, "stdio-odirect"):
		nfs_locktest_cleanup(tf)

	# At one point, a POSIX unlock would imply a flush of any
	# mmapped pages covered by the lock, but it seems this code
	# was intentionally removed.
	# And it makes sense to not try to support this feature,
	# because it only really works if locks are page aligned.
	if False:
		journal.beginTest("locked mmap with implicit flush/revalidate" + extramsg)
		if not __nfs_test_lock_coherence(tf, "mmap"):
			nfs_locktest_cleanup(tf)

	journal.beginTest("locked mmap/msync coherence" + extramsg)
	if not __nfs_test_lock_coherence(tf, "mmap-sync"):
		nfs_locktest_cleanup(tf)

	# client2.run("/usr/sbin/rpcdebug -m nlm -c all")

def nfs_test_coherence():

	global journal, client1, client2, server

	journal.beginGroup("coherence-init")

	if not client1.run("test -x /usr/bin/nfs"):
		journal.error("/usr/bin/nfs missing on client1")
		return False
	if not client2.run("test -x /usr/bin/nfs"):
		journal.error("/usr/bin/nfs missing on client2")

	exports_data = '''
/srv/nfs/dir1	*(rw,no_root_squash,no_subtree_check)
'''
	nfs_write_verify_exports(server, exports_data)

	for options in ["vers=2", "vers=3", "vers=4"]:
		# Better safe than sorry
		options = nfs_join_mount_options(options, "intr");

		journal.beginGroup("coherence-%s" % options)

		journal.beginTest("Mounting dir with options " + options)
		if not nfs_do_mount(client1, server.ipaddr, "dir1", options):
			journal.info("Skipping locking tests for these options - cannot mount directory");
			continue;

		if not nfs_do_mount(client2, server.ipaddr, "dir1", options):
			journal.info("Skipping locking tests for these options - cannot mount directory");
			nfs_do_umount(client1, dir)
			continue;

		testfile = __nfs_client_file("dir1") + "/testfile"
		if nfs_test_wait_grace(client1, testfile):
			nfs_test_cto(testfile)
			nfs_test_lock_coherence(testfile, options)
		else:
			journal.warning("Skipping all coherence tests")

		client1.runOrFail("rm -f " + testfile)

		nfs_do_umount(client1, "dir1")
		nfs_do_umount(client2, "dir1")

def main():
	nfs_init_all()
	nfs_test_mount()
	nfs_test_exports()
	nfs_test_sysvinit()
	nfs_test_fileops()
	nfs_test_nfsv4_grace()
	nfs_test_locking()
	nfs_test_coherence()


try:
	main()
except:
	import traceback

	journal.error("Oops, caught unexpected exception")
	journal.info(traceback.format_exc(None))

susetest.finish(journal)
